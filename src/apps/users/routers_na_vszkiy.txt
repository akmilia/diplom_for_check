
#очень интересно, но нафиг оно надо - это админка, которой тут нет
# @router.post('/subjects', response_model=SubjectSchema, dependencies=[Depends(admin)])
# async def create_subject(
#     session: AsyncSession,
#     subject_data: SubjectCreateSchema
# ):
#     # Создаем новый предмет
#     new_subject = Subjects(
#         name=subject_data.name,
#         description=subject_data.description
#     )
#     session.add(new_subject)
#     await session.commit()
#     await session.refresh(new_subject)
    
#     # Создаем связь с типом
#     for type_id in subject_data.type_ids:
#         type_subject = TypesSubjects(
#             types_id=type_id,
#             subjects_idsubjects=new_subject.idsubjects
#         )
#         session.add(type_subject)
    
#     await session.commit()
   
#     # Получаем созданный предмет из представления
#     created_subject = (await session.execute(
#         select(SubjectSchema)
#         .where(SubjectSchema.id == new_subject.idsubjects)
#     )).scalar_one_or_none()
    
#     if not created_subject:
#         raise HTTPException(status_code=500, detail='Ошибка при создании предмета')
  
#     return created_subject

# @router.get('/schedule', response_model=list[ScheduleEntryResponse])
# async def get_schedule(
#     session: AsyncSession,
#     day_of_week: str,
#     group_id: Optional[int] = None  # type: ignore
# ):
#     # Базовый запрос с загрузкой связанных данных
#     query = (
#         select(Schedule)
#         .options(
#             joinedload(Schedule.subjects),
#             joinedload(Schedule.users),
#             joinedload(Schedule.cabinets),
#             joinedload(Schedule.groups),
#             joinedload(Schedule.attendance)
#         )
#     )
    
#     # Применяем фильтры
#     if day_of_week:
#         query = query.where(Schedule.day_of_week == day_of_week)
#     if group_id:
#         query = query.where(Schedule.groups_idgroup == group_id)
    
#     # Выполняем запрос
#     schedules = (await session.execute(query)).unique().scalars().all()
    
#     if not schedules:
#         raise HTTPException(status_code=404, detail='Расписание не найдено')
    
#     # Преобразуем в ответ
#     result = []
#     for schedule in schedules:
#         # Получаем даты занятий из Attendance
#         dates = [a.date.strftime("%d.%m.%Y") for a in schedule.attendance]
        
#         # Преобразуем день недели из числа в текст
#         day_names = {
#             1: "Понедельник",
#             2: "Вторник",
#             3: "Среда",
#             4: "Четверг",
#             5: "Пятница",
#             6: "Суббота"
#         }
        
#         result.append(ScheduleEntryResponse(
#             idschedule=schedule.idschedule,
#             time=schedule.time.strftime("%H:%M"),
#             subject_name=schedule.subjects.name,
#             teacher=ScheduleTeacherSchema(
#                 id=schedule.users.idusers,
#                 surname=schedule.users.surname,
#                 name=schedule.users.name,
#                 paternity=schedule.users.paternity
#             ),
#             cabinet=schedule.cabinets.idcabinet,  # или schedule.cabinets.name, если есть название
#             group_name=schedule.groups.name if schedule.groups else None,
#             day_of_week=day_names.get(schedule.day_of_week, "Неизвестно"),
#             dates=dates
#         ))
    
#     return result 



# @router.get('/subjects', response_model=list[Subject], dependencies=[Depends(admin)])
# async def get_subjects(session: AsyncSessionDep):
#     return (await session.execute(select(Subject))).scalars().all()


# @router.post('/subjects', response_model=Subject, dependencies=[Depends(admin)])
# async def create_subject(session: AsyncSessionDep, subject_schema: SubjectSchema):
#     subject = Subject(
#         name=subject_schema.name,
#         description=subject_schema.description,
#         type=subject_schema.type,
#     )
#     session.add(subject)
#     await session.commit()
#     await session.refresh(subject)
#     return subject 



# @router.post('/login', response_model=BearerSchema)
# async def login(session: AsyncSessionDep, login_data: LoginSchema):
#     user = (
#         await session.execute(
#             select(User)
#             .where(User.login == login_data.login)
#             .where(User.password == login_data.password)
#         )
#     ).scalar_one_or_none()

#     if not user or not user.id:
#         raise HTTPException(status_code=404, detail='User not found')

#     role = (await session.execute(select(Role).where(Role.id == user.role_id))).scalar_one()

#     user_session = SessionSchema(role=role.name, user_id=user.id)
#     encoded_jwt = str(encode(user_session.model_dump(), SECRET_KEY, algorithm=ALGORITHM))

#     return BearerSchema(access_token=encoded_jwt, role=role.name)


# @router.get('/profile', response_model=Users, dependencies=[Depends(user_auth)])
# async def get_profile(user: Annotated[User, Depends(user_auth)]):
#     return user
